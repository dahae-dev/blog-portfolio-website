---
title: "Javascript - Asynchronous Call"
date: 2019-05-16T18:31:00.000Z
tags: ["javascript", "asynchronous", "callback", "event-loop"]
category: blog
open: true
---

<br />

자바스크립트는 싱글 쓰레드(single-threaded) 프로그래밍 언어로, 자바스크립트 엔진은 한 번에 한 가지의 일만을 처리한다. 싱글 쓰레드 언어는 동시성(concurrecy) 문제를 걱정할 필요가 없으므로 코드 작성이 단순화되는 반면, 네트워크 접속과 같은 긴 시간이 걸리는 오퍼레이션의 경우 메인 쓰레드를 막지 않고는 수행할 수가 없다.  

만약 API로부터 데이터를 요청하는 경우, 상황에 따라 서버가 해당 요청을 처리하는데 시간이 오래 걸릴 수 있는데, 이는 메인 쓰레드를 막아 웹페이지 전체를 먹통으로 만들어 버릴 수 있다.  

이러한 관점에서 바로 자바스크립트의 비동기 프로그래밍(Asynchronous Programming)의 개념이 들어온다. 비동기 프로그래밍을 통해 오래 걸리는 네트워크 요청도 메인 쓰레드를 막지 않고(Non-blocking) 처리할 수 있다. 즉, XHR 요청의 응답을 기다릴 때에도 여전히 사용자 입력 등과 같은 다른 것들을 처리할 수 있게 되는 것이다.  

한 마디로 요약하자면, 자바스크립트의 비동기 처리란 `특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행`하는 자바스크립트의 특성을 의미한다. 이러한 특성을 이해하기 위해서 먼저 자바스크립트 엔진 내부에서 코드가 어떻게 실행되는지부터 이해해야 한다.  

<br />

## 자바스크립트 코드 실행 과정

---

자바스크립트의 코드 실행 과정을 이해하기 위해서는 앞선 포스팅들에서도 언급했던 실행 컨텍스트(E xecution Context) 및 호출 스택(Call Stack)에 대한 개념을 먼저 알고 있어야 한다.  

다시 한 번 정리를 해보자면, `실행 컨텍스트`는 자바스크립트 코드가 실행되는 환경에 대한 추상적 개념으로, 자바스크립트 코드는 항상 이 실행 컨텍스트 안에서 실행된다.  
`호출 스택`은 LIFO(Last In, First Out) 구조의 스택으로, 코드가 실행되는 동안 생성된 실행 컨텍스트가 저장되는 곳이다. 자바스크립트는 싱글 쓰레드 기반의 언어이기 때문에, 단 하나의 호출 스택만을 가진다.  

자바스크립트 엔진 내에서 코드가 실행될 때, 호출 스택은 다음과 같이 작동한다.
- 스크립트가 불러지면, 가장 먼저 전역 컨텍스트가 생성되어 호출 스택에 추가(push)된다.  
- 함수가 호출되면, 해당 함수 컨텍스트가 생성되어 호출 스택에 추가(push)된다.
- 함수 내부에서 변수에 대입이 일어나면, 호출스택에 저장되어 있는 함수 컨텍스트 내 변수의 내용을 변경한다.
- 함수 실행이 끝나면, 결과값을 반환하고 호출 스택 가장 위에 있는 실행 컨텍스트를 제거(pop)한다.
- 스크립트가 완료되면, 전역 컨텍스트를 호출 스택에서 제거(pop)한다.

```js
const second = () => {
  console.log('#2');
}
const first = () => {
  console.log('#1');
  second();
  console.log('Finish');
}
first();
```

위와 같은 코드를 실행시키면, 호출 스택에 `전역 컨텍스트` 다음으로 `first()`의 실행 컨텍스트가 저장된다. 그리고 `console.log('#1')`가 스택의 가장 위에 저장(push)되고, 즉시 실행 후 다시 스택으로부터 제거(pop)된다. 다음으로 호출된 `second()`가 다시 스택에 저장되고, `console.log('#2')`가 그 위에 저장된 다음 똑같이 즉시 실행 후 다시 스택에서 제거된다. 이로써 `second()`의 실행도 완료되었으니 호출 스택에서 제거된다. 그리고 다시 `console.log('Finish')`가 스택에 저장된 다음, 동일하게 즉시 실행 후 제거된다. 이제 `first()` 함수 실행이 종료되었으니, 스택에서 제거되고, 프로그램이 종료되면 `전역 컨텍스트`가 마지막으로 스택에서 제거되고 종료된다. 이것이 동기적(Synchronous)으로 동작하는 자바스크립트 코드에 대한 기본 배경이다.  

<br />

이처럼 호출 스택에 실행 컨텍스트가 존재하는 동안, 즉 실행 중인 함수가 존재하는 동안에는 이 함수들이 메인 쓰레드를 막고(blocking) 있기 때문에 다른 작업을 수행할 수가 없다. 이러한 특성은 이미지 처리나 네트워크 자원 요청과 같이 오랜 시간이 걸리는 코드들로 인해, 다소 빠른 시간 내에 즉시 실행하여 완료될 수 있는 코드들의 실행을 막음으로써 비효율을 야기하기도 한다.  
바로 이와 같이 오래 기다려야 하는 일을 처리하기 위한 해결책으로 제시되는 것이 `비동기 콜백`이다.

<br />

## 비동기는 어떻게 동작하는가?

---

비동기 콜백(Asynchronous callbacks)은 이러한 자바스크립트 코드를 `non-blocking`하게 만들어준다. 

> ### Callback

우선 콜백이란, 다른 함수의 인자(arguments)로서 넘겨주는 함수를 의미한다. 콜백을 parameter로 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고(synchronously), 아니면 나중에 실행할 수도 있다(asynchronously).

#### iterator 로 사용될 때 - synchronous callback

map의 arguments로 넘어간 익명함수가 callback 함수로서, 넘겨받는 즉시 실행된다.
```js
[1,2,3].map(function(element){
     return element * element;
}) 
```

#### Event handler 로 사용될 때 - asynchronous callback

버튼 클릭 이벤트의 핸들러로 넘어간 익명함수가 callback 함수로서, click 이벤트 발생시 실행된다.
```js
$('button').on('click', function(e){
     console.log('button clicked');
}) 
```

setTimeout의 첫 번째 인자로 넘어간 익명함수가 callback 함수로서, 먼저 `console.log('world')` 코드가 실행되어 콘솔에 'world'가 찍힌 다음, 타이머가 모두 완료된 후 'hello'가 찍힌다.

```js
setTimeout(() => {
  console.log('hello');
}, 2000); // 2초 뒤에 콜백이 작업 큐로 넘어감

console.log('world');
```

앞서 지속적으로 말했듯이 자바스크립트는 싱글 쓰레드 기반의 언어로 하나의 호출 스택만을 사용하는데도 불구하고, 이와 같이 동시성(concurrency)이 지원되는 이유는 바로 `Event Loop`에 의해 가능하다.

> ### Event loop

우선 간단히 설명하자면, 

- 오래 기다려야 하는 일에 대한 처리는 자바스크립트 엔진에서 직접 핸들링하지 않고, `Web APIs`를 통해 브라우저로 넘기는데 이 때 작업이 완료되고 나면 실행시킬 콜백을 함께 등록한다.
- 콜백함수들을 보관하는 공간인 `작업 큐(Task Queue)`을 마련해 놓고, 위임한 작업이 완료되면 함께 등록되었던 콜백을 작업 큐로 넘겨준다.
- 동기 작업이 모두 끝나 호출 스택(Call Stack)이 비워지면 `이벤트 루프(Event Loop)`에 의해 작업 큐에서 가장 오래된 작업(콜백)부터 실행한다.

즉, 이벤트 루프의 역할은 호출 스택을 확인하여 비워졌는지 아닌지를 확인하여, 스택이 비워졌다면 작업 큐를 확인하여 혹시 실행 대기 중인 펜딩 상태의 콜백이 있는지를 확인하는 것이다. 참고로 이벤트 루프, Web APIs(또는 C/C++ APIs), 작업 큐는 모두 자바스크립트 엔진의 일부가 아니라, 브라우저 혹은 Node.js의 자바스크립트 런타임 환경의 일부분이라고 한다.

<br />

이러한 비동기 처리에 대한 예시로는 다음과 같은 것들이 있다.
- DOM Events에 대한 이벤트 핸들러
- Timer APIs에서의 콜백
- 서버에의 자원 요청(ajax call)에 따른 콜백

이 중 앞서 했듯이 간단하게 예시를 들어 비동기 처리에 대한 이해를 도울 수 있는 Timer APIs에 관해 좀 더 살펴보고자 한다.

> ### Timer APIs

Web APIs에는 타이머와 관련된 API들 - `setTimeout()`, `setInterval()` - 이 있는데, 이 함수들은 2개의 인수,`1) 콜백함수(작업 큐에 추가 할 메시지)`와 `2) Delay time(optional, defalut값은 0)`으로 호출된다. 여기서 Delay time은 메시지가 실제로 큐에 푸시 될 때까지의 `최소 지연시간`을 나타낸다. 큐에 다른 메시지가 없으면 delay 직후에 메시지가 처리된다. 하지만 메시지가 있는 경우, 해당 메시지는 다른 메시지가 처리 될 때까지 기다려야 하기 때문에, 두 번째 인수는 최소 시간을 나타내지만 보장된 시간은 아닌 것이다.

`setTimeout()`의 내부 동작 과정을 좀 더 들여다 보면, setTimeout() 코드가 실행되자 마자 비동기 영역(Web APIs)으로 콜백함수가 넘어가고 타이머는 바로 실행된다. 타이머가 끝나면 그 때 작업 큐로 콜백함수가 넘어와 동기 작업이 모두 끝나고 호출 스택이 비워질 때까지 기다렸다가 큐에 들어왔던 순서대로 호출 스택으로 넘어가 실행된다.

간단한 예제를 통해 setTimeout에 대한 동작 과정을 이해할 수 있다.

#### 예제 1

```js
console.log("A");

setTimeout(function() {
  console.log("B");
}, 1000);

setTimeout(function() {
  console.log("C");
}, 500);

console.log("D");

// output: A - D - C - B
```

먼저 제일 처음 console.log 함수가 즉시 실행되어 콘솔에 "A"가 찍힌다. 첫 번째 setTimeout의 코드가 실행되는 순간 "B"를 찍는 콜백함수는 Web API로 넘어간 다음, 1s가 흐른 후에 큐로 넘어간다. 두 번째 setTimeout의 코드가 실행되는 순간 "C"를 찍는 콜백함수는 Web API로 넘어간 다음, 0.5s 뒤에 큐로 넘어간다. 그리고 마지막의 console.log 함수가 즉시 실행되어 콘솔에 "D"가 찍힌다. 이와 같은 동기 작업이 먼저 완료된 후, 큐에 저장된 순서대로 콜백함수를 실행한다. 지연시간이 더 짧아 먼저 큐에 들어간 "C"를 찍는 함수가 먼저 실행되고, 마지막으로 "B"가 콘솔에 찍히는 함수가 실행된다.

#### 예제 2

```js
console.log("A");

setTimeout(function() {
  console.log("B");
}, 0);

console.log("C");

// output: A - C - B
```

동일하게 동기 작업인 "A", "C"를 콘솔에 찍는 함수들이 먼저 실행이 되고, "B"를 찍는 콜백은 우선 비동기 영역으로 넘어간 다음 즉시(0초 뒤) 큐로 넘어간 다음 실행이 된다. 여기서 지연시간이 0초라고 하여 지연없이 바로 콜백함수가 실행되는 것이 아니라, 무조건 콜백은 비동기 영역인 Web API로 넘어간 이후 작업 큐를 거쳐서 호출 스택으로 넘겨진다는 것을 알아야 한다.

#### 예제 3

```js
console.log("A");

setTimeout(function() {
  console.log("B");
}, 1000);

superLongComputation(); // synchronous, takes 5s to run

console.log("C");

// output: A - B - C
```

먼저 "A"가 콘솔에 찍힌 다음, 비동기 영역으로 넘어간 "B"를 찍는 콜백을 건너뛰고 그 다음 동기작업인 superLongComputation 함수가 콜 스택에 들어가 실행된다. 하지만 이는 5초라는 시간이 걸리기 때문에, 그 다음 "C"를 찍는 함수를 실행할 수 없고 5초가 모두 완료될 때까지 기다려야 한다. 이 사이에 이미 비동기 영역으로 넘어간 "B"를 찍는 콜백이 1초 만에 작업 큐로 넘어와 있기 때문에, superLongComputation 함수가 종료되어 콜 스택이 비워지는 순간, 큐에서 대기 중이던 콜백이 콜 스택으로 넘어와 실행되기 때문에 "B"가 먼저 찍힌 다음, 마지막으로 "C"를 찍는 함수가 콜 스택에 들어가 실행되게 된다.

#### 예제 4

```js
console.log("A");

setTimeout(function() {
  console.log("B");
}, 500);

setTimeout(console.log("C"), 1000);

// output: A - C - B
```

동일하게 먼저 "A"가 콘솔에 찍히고, 첫 번째 setTimeout 코드가 실행되면 "B"를 찍는 콜백은 비동기 영역으로 넘어간 다음, 두 번째 setTimeout 코드가 실행되면, 첫 번째 인자로 넘겨받은 함수가 콜백이 아니라 즉시 실행되는 console.log() 함수이기 때문에 바로 "C"가 찍힌 다음, 큐에서 넘겨받은 "B"를 찍는 콜백함수가 실행된다.

<br />

### Reference

https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff - Call Stack 및 Event Loop에 대한 시각적 이미지  
https://youtu.be/8aGhZQkoFbQ - Event Loop 영상  
https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop